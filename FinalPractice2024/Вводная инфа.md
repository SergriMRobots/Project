## 1. Необходимые приготовления 

По идее на Huawei ноуте это уже все есть. И если используется он, то данные 

Для сборки проекта необходимо несколько штук:

- Установленный **ROS Noetic.** Туториал по установке смотри [Тут](http://wiki.ros.org/noetic/Installation/Ubuntu). По идее должно хватить и **Desktop Install** версии, но если нет каких-то внутренних противоречий, то лучше поставить **Desktop-Full Install** версию. **ROS-Base** версия не подойдет, так как без rviz-a и rqt будет не особо клево, их можно будет доставить и этот процесс за рамками данного туториала и зачем страдать, если можно не страдать.
- Установленный **Catkin Tools.** Туториал по установке смотри [Тут](https://catkin-tools.readthedocs.io/en/latest/installing.html). Везде в туториал первого ROS используется **catkin_make**. Поцанов из Catkin Tools это настолько допекло, что они замутили [Migration Guide](https://catkin-tools.readthedocs.io/en/latest/migration.html). Далее будет использоваться Catkin Tools

К ROS-у нужно будет еще ряд важных пакетов: 

**Moveit**:

`sudo apt install ros-noetic-moveit` - мета-пакет устанавливающий пакеты фреймворка Moveit в ROS 

Вроде как этот пакет также ставит и ванильную версию moveit_servo. Под ванильной версией я понимаю версию пакета вот [отсюда ](https://github.com/moveit/moveit/tree/1.1.14/moveit_ros/moveit_servo) . Она же, но только в виде исходников и части workspace **tms_ws_lite** лежит в папке  [[src/moveit_servo_vanilla_1.1.14]] 

В этом же репозитории лежит [[src/moveit_servo]] это наша фантазия на тему moveit_servo.

**Ros control**: 

По сути абстракция для ROS1 для управления роботами различных вендером через набор обобщенных программных модулей (a.k.a контроллеров). Вики тут: https://wiki.ros.org/ros_control

Здесь я просто перечислю набор пакетов, которые надо будет доставить если еще не:

- ros-noetic-scaled-joint-trajectory-controller - траекторный контроллер, используемый когда надо с помощью Moveit заранее спланировать и исполнить траекторию для перехода в заранее известное положение
- ros-noetic-control-toolbox 
- ros-noetic-controller-interface
- ros-noetic-controller-manager`
- ros-noetic-industrial-robot-status-controller
- ros-noetic-industrial-robot-status-interface
- ros-noetic-speed-scaling-interface
- ros-noetic-speed-scaling-state-controller 
- ros-noetic-pass-through-controllers 
- ros-noetic-ros-controllers - ставит в том числе и **joint_state_controller** - основной контроллер проброса текущей телеметрии робота в ROS
## 2. Ньюансы сборки

Так как [[moveit_servo|наш]] и [[moveit_servo_vanilla_1.1.14|исходный]]  пакеты серво управления формируют в итоге пакет с именем **moveit_servo**, то если не кинуть пустой  файл с именем **CATKIN_IGNORE** в ту версию пакета, которую мы не хотим проверять и тестить, то можно получить ошибку сборки workspace, так как catkin не может разрешить какую версию пакета с именем **moveit_servo** ему использовать. 

При каждой смене версии пакета нужно:
1. Делать
	1. либо чистую сборку всего workspace
		 catkin clean; catkin build
	2.  либо только pre-clean moveit_servo (этот вариант не тестил сам)
		 catkin build --pre-clean moveit_servo
2. Делать source devel/setup.bash чтобы обновить ROS Path в окружении консоли

**Небольшой оффтоп:**

Не тестил мануал прям на чистую ubuntu и свежеустановленный ros, но все самописные пакеты в этом проекте содержат либо "tms" (исключение spacenav_sim он тоже самописный из другого проекта) префикс внутри себя. Поэтому если сборка жалуется, что

```
"Could not find a package configuration file provided by "**package_name**"
```

Надо чекнуть, что **package_name** не что-то самописное, а как доставить что-то не самописное можно загуглить, как правило там будет инструкция типа:

```
#Если это ros-пакет
sudo apt install ros-noetic-**package_name**

#Если это какая-то либа
sudo apt install lib**package_name**-dev
```

И вообще любой туториал - это как паста про батин суп. Вариантов что именно может пойти не так в каждом новом случае масса и все покрыть просто не реально, поэтому и данный туториал - рецепт примерно усредненный.

Ну и собирать проект за кем-то это процесс всегда сопровождаемые полушепотом "ух бля"

**Конец небольшого оффтопа**

## 3. Подготовка виртуалки UR Sim

Так как основной платформой проекта является UR5 CB серии, то необходима виртулка с **UR Sim 3.х** версией Polyscope. Важно чтобы в этой виртуалке был установлен [External Control](https://github.com/UniversalRobots/Universal_Robots_ExternalControl_URCap)  и существовала программа **ur_ros_driver.urp** (Именно так эта программа захардкожена в пульте).

Вот [Туториал](https://github.com/UniversalRobots/Universal_Robots_ROS_Driver/blob/master/ur_robot_driver/doc/install_urcap_cb3.md) как настроить всё на CB серии UR-ки 

Тут можно пойти двумя путями: 

### 1. Через Docker Container  

Можно попробовать стянуть образ с [Docker Hub](https://hub.docker.com/r/universalrobots/ursim_cb3). **Upd**: Часть этого текста это вырезки из других внутренних доков других проектов. На момент написания этой части стянуть еще можно было, но теперь либо через левые прокси, либо прости, Марио, твоя принцесса в другом замке, так как ты пытаешься стянуть образ с неправильной, по мнению Docker, части голубого шарика. **UPD 2:** Хотя вроде как доступ к Docker Hub опять вернулся, хз надолго ли.   

По идее вариант менее ресурсожрущий, но мне он не нравиться тем, что на момент написания туториала у меня часто падал OpenVNC открываемый данным образом для отображения GUI Polyscope.
### 2. Через виртуалку для Virtual Box
Варик более ресурсожрущий зато более стабильный. 
Мануал и образ можно взять [тут](https://www.universal-robots.com/download/software-cb-series/simulator-non-linux/offline-simulator-cb-series-non-linux-ursim-3158/)
Если линк дропнут, то вот [линк](https://www.universal-robots.com/download/)  на Download Center Universal Robots. Там надо прожмякать Filter->Software->Non-Linux Offlne simulator. Выбрать пункт **OFFLINE SIMULATOR - CB-SERIES - NON LINUX - URSIM 3.x** ну и почитать и выполнить мануал в этом пункте. **Примечание:** Для скачивания там нужно будет залогиниться, хз банят ли сейчас возможность регистрации если ты это делаешь с неправильной по мнению Universal Robots части голубого шарика, но я уверен, что читающий найдет возможность получить желаемое

### 3. Пару слов про IP адреса
По историческим причинам IP именно UR роботов имеет вид: **192.168.х.101**

И вот в этом X в основном и есть разница какая именно подсеть виртуалки запущена:
1. 56 - подсеть используется для VirtualBox 
2. 1 - эта подсеть использовалась для Docker образа, который не особо взлетел, но память о нем осталась в виде дефолтного Ipшника в [ur5_demo_driver.launch](src/tms/tms_common/launch/ur5_demo_driver.launch)

